lasdi.fd
========

.. py:module:: lasdi.fd


Attributes
----------

.. autoapisummary::

   lasdi.fd.FDdict


Classes
-------

.. autoapisummary::

   lasdi.fd.Stencil
   lasdi.fd.SBP12
   lasdi.fd.SBP24
   lasdi.fd.SBP36
   lasdi.fd.SBP48


Module Contents
---------------

.. py:class:: Stencil

   .. py:attribute:: leftBdrDepth
      :type:  int
      :value: 0



   .. py:attribute:: leftBdrWidth
      :type:  list[int]
      :value: []



   .. py:attribute:: leftBdrStencils
      :type:  list[list[float]]
      :value: [[]]



   .. py:attribute:: leftBdrNorm
      :type:  list[float]
      :value: []


      Suppose that InteriorStencils is an array of length Ns and interiorIndexes is a list of
      length Ns. Further suppose the underlying time series contains Nx points, x(t_0), ... ,
      x(t_{Nx -1}). Assuming index i is an "interior index" (not too close to 0 or Nx - 1), then we
      approximate the time derivative of z at time t_i as follows:
          z'(t_i) pprox c_0 z(t_{i + i(0)}) + ... + c_{Ns - 1} z(t_{i + i(Ns - 1)})
      where c_k = interiorStencils[k] and i(k) = interiorIndexes[k]. Note that the indices may be
      negative or positive. Thus, interiorStencils and interiorIndexes tell us how to construct the
      finite difference scheme away from the boundary.
      x
      For instance, the central difference scheme corresponds to interiorStencils = [-1/2, 1/2],
      interiorIndexes = [-1, 1] and
          z'(t_i) pprox (1/2)(-z(t_{i - 1}) + z_{t_{i + 1}})

      Note: We assume that interiorIndexes is in ASCENDING order.


   .. py:attribute:: interiorStencils
      :type:  numpy.ndarray


   .. py:attribute:: interiorIndexes
      :type:  list[int]
      :value: []



   .. py:method:: getOperators(Nx: int, periodic: bool = False) -> tuple[scipy.sparse.spmatrix, torch.Tensor, torch.Tensor]

      The stencil class acts as an abstract base class for finite difference schemes. We assume
      that the user has a time series, x(t_0), ... , x(t_{Nx - 1}) \in \mathbb{R}^d. We will
      further assume that the time stamps are evenly spaced, t_0, ... , t_{Nx - 1}. That is,
      there is some \Delta t such that t_k = t_0 + \Delta_t*k for each k. We also assume the user
      wants to approximate the time derivative of x at t_0, ... , t_{Nx - 1} using a finite
      difference scheme.

      The getOperators method builds an a sparse Tensor housing the "operator matrix". This is
      an Nx x Nx matrix that we use to apply the finite difference scheme to one component of
      the time series. How does this work? Suppose the time series is x(t_0), ... ,
      x(t_{Nx - 1}) \in \mathbb{R}^d. Then, for each i \in \{ 1, 2, ... , d}, we construct Dxi
      such that Dxi * xi is the vector whose i'th entry holds the approximation (using the
      selected finite difference scheme) of x_i'(t_i). Here, xi = [x_i(t_0), ... ,
      x_i(t_{Nx - 1})]. To build Dxi, we first set up a matrix to give the correct approximation
      to x_i'(t_j) whenever j is an interior index. The rest of this function adjusts the
      first/last few rows of Dxi so that it also gives the correct approximation at the
      boundaries (j close to to 0 or Nx - 1).

      The Stencil class is not a standalone class; you shouldn't use it directly. Rather, you
      should use one of the sub-classes defined below. Each one implements a specific finite
      difference scheme to approximate the time derivatives at t_0, ... , t_{Nx - 1} (they may
      use different rules on the left and right boundary). Each sub-class should set the
      interiorStencils and interiorIndexes attributes.


      -------------------------------------------------------------------------------------------
      :Parameters: * **Nx** (*An integer specifying the number of points in the time series we want to apply a*)
                   * **finite difference scheme to.**
                   * **periodic** (*A boolean specifying if we should treat the time series as periodic or not.*)

      -------------------------------------------------------------------------------------------
      :returns: * *Three elements. The first Dxi, the "Operator Matrix" described above. The second holds the*
                * *"norm" tensor and the third holds the "PeriodicOffset" tensor.*
                * **TODO** (*what are the last two of these used for? And what are they?*)



   .. py:method:: convert(scipy_coo: scipy.sparse.spmatrix) -> torch.Tensor

      Converts scipy_coo, a sparse numpy array, to a sparse torch Tensor.


      -------------------------------------------------------------------------------------------
      :Parameters: **scipy_coo** (*A sparse numpy array.*)

      -------------------------------------------------------------------------------------------
      :rtype: A tensor version of scipy_coo.



.. py:class:: SBP12

   Bases: :py:obj:`Stencil`


   .. py:attribute:: leftBdrDepth
      :value: 1



   .. py:attribute:: leftBdrWidth
      :value: [2]



   .. py:attribute:: leftBdrStencils


   .. py:attribute:: leftBdrNorm
      :value: [0.5]


      Suppose that InteriorStencils is an array of length Ns and interiorIndexes is a list of
      length Ns. Further suppose the underlying time series contains Nx points, x(t_0), ... ,
      x(t_{Nx -1}). Assuming index i is an "interior index" (not too close to 0 or Nx - 1), then we
      approximate the time derivative of z at time t_i as follows:
          z'(t_i) pprox c_0 z(t_{i + i(0)}) + ... + c_{Ns - 1} z(t_{i + i(Ns - 1)})
      where c_k = interiorStencils[k] and i(k) = interiorIndexes[k]. Note that the indices may be
      negative or positive. Thus, interiorStencils and interiorIndexes tell us how to construct the
      finite difference scheme away from the boundary.
      x
      For instance, the central difference scheme corresponds to interiorStencils = [-1/2, 1/2],
      interiorIndexes = [-1, 1] and
          z'(t_i) pprox (1/2)(-z(t_{i - 1}) + z_{t_{i + 1}})

      Note: We assume that interiorIndexes is in ASCENDING order.


   .. py:attribute:: interiorStencils


   .. py:attribute:: interiorIndexes


.. py:class:: SBP24

   Bases: :py:obj:`Stencil`


   .. py:attribute:: leftBdrDepth
      :value: 4



   .. py:attribute:: leftBdrWidth
      :value: [4, 3, 5, 6]



   .. py:attribute:: leftBdrStencils


   .. py:attribute:: leftBdrNorm

      Suppose that InteriorStencils is an array of length Ns and interiorIndexes is a list of
      length Ns. Further suppose the underlying time series contains Nx points, x(t_0), ... ,
      x(t_{Nx -1}). Assuming index i is an "interior index" (not too close to 0 or Nx - 1), then we
      approximate the time derivative of z at time t_i as follows:
          z'(t_i) pprox c_0 z(t_{i + i(0)}) + ... + c_{Ns - 1} z(t_{i + i(Ns - 1)})
      where c_k = interiorStencils[k] and i(k) = interiorIndexes[k]. Note that the indices may be
      negative or positive. Thus, interiorStencils and interiorIndexes tell us how to construct the
      finite difference scheme away from the boundary.
      x
      For instance, the central difference scheme corresponds to interiorStencils = [-1/2, 1/2],
      interiorIndexes = [-1, 1] and
          z'(t_i) pprox (1/2)(-z(t_{i - 1}) + z_{t_{i + 1}})

      Note: We assume that interiorIndexes is in ASCENDING order.


   .. py:attribute:: interiorStencils


   .. py:attribute:: interiorIndexes


.. py:class:: SBP36

   Bases: :py:obj:`Stencil`


   .. py:attribute:: leftBdrDepth
      :value: 6



   .. py:attribute:: leftBdrWidth
      :value: [6, 6, 6, 7, 8, 9]



   .. py:attribute:: leftBdrStencils


   .. py:attribute:: leftBdrNorm

      Suppose that InteriorStencils is an array of length Ns and interiorIndexes is a list of
      length Ns. Further suppose the underlying time series contains Nx points, x(t_0), ... ,
      x(t_{Nx -1}). Assuming index i is an "interior index" (not too close to 0 or Nx - 1), then we
      approximate the time derivative of z at time t_i as follows:
          z'(t_i) pprox c_0 z(t_{i + i(0)}) + ... + c_{Ns - 1} z(t_{i + i(Ns - 1)})
      where c_k = interiorStencils[k] and i(k) = interiorIndexes[k]. Note that the indices may be
      negative or positive. Thus, interiorStencils and interiorIndexes tell us how to construct the
      finite difference scheme away from the boundary.
      x
      For instance, the central difference scheme corresponds to interiorStencils = [-1/2, 1/2],
      interiorIndexes = [-1, 1] and
          z'(t_i) pprox (1/2)(-z(t_{i - 1}) + z_{t_{i + 1}})

      Note: We assume that interiorIndexes is in ASCENDING order.


   .. py:attribute:: interiorStencils


   .. py:attribute:: interiorIndexes


.. py:class:: SBP48

   Bases: :py:obj:`Stencil`


   .. py:attribute:: leftBdrDepth
      :value: 8



   .. py:attribute:: leftBdrWidth
      :value: [8, 8, 8, 8, 9, 10, 11, 12]



   .. py:attribute:: leftBdrNorm

      Suppose that InteriorStencils is an array of length Ns and interiorIndexes is a list of
      length Ns. Further suppose the underlying time series contains Nx points, x(t_0), ... ,
      x(t_{Nx -1}). Assuming index i is an "interior index" (not too close to 0 or Nx - 1), then we
      approximate the time derivative of z at time t_i as follows:
          z'(t_i) pprox c_0 z(t_{i + i(0)}) + ... + c_{Ns - 1} z(t_{i + i(Ns - 1)})
      where c_k = interiorStencils[k] and i(k) = interiorIndexes[k]. Note that the indices may be
      negative or positive. Thus, interiorStencils and interiorIndexes tell us how to construct the
      finite difference scheme away from the boundary.
      x
      For instance, the central difference scheme corresponds to interiorStencils = [-1/2, 1/2],
      interiorIndexes = [-1, 1] and
          z'(t_i) pprox (1/2)(-z(t_{i - 1}) + z_{t_{i + 1}})

      Note: We assume that interiorIndexes is in ASCENDING order.


   .. py:attribute:: leftBdrStencils


   .. py:attribute:: interiorStencils


   .. py:attribute:: interiorIndexes


.. py:data:: FDdict

