lasdi.physics.burgers1d
=======================

.. py:module:: lasdi.physics.burgers1d


Classes
-------

.. autoapisummary::

   lasdi.physics.burgers1d.Burgers1D


Functions
---------

.. autoapisummary::

   lasdi.physics.burgers1d.residual_burgers
   lasdi.physics.burgers1d.jacobian
   lasdi.physics.burgers1d.solver
   lasdi.physics.burgers1d.main


Module Contents
---------------

.. py:class:: Burgers1D(cfg: dict, param_name: list[str] = None)

   Bases: :py:obj:`lasdi.physics.Physics`


   .. py:attribute:: a_idx
      :value: None



   .. py:attribute:: w_idx
      :value: None



   .. py:attribute:: qdim
      :type:  int
      :value: 1



   .. py:attribute:: dim
      :type:  int
      :value: 1



   .. py:attribute:: offline
      :type:  bool


   .. py:attribute:: nt
      :type:  int


   .. py:attribute:: grid_size
      :type:  list[int]


   .. py:attribute:: qgrid_size
      :type:  list[int]

      numpy nd-array, assuming the shape of:
      - 1d: (space_dim[0],)
      - 2d: (2, space_dim[0], space_dim[1])
      - 3d: (3, space_dim[0], space_dim[1], space_dim[2])
      - higher dimension...


   .. py:attribute:: xmin


   .. py:attribute:: xmax


   .. py:attribute:: dx


   .. py:attribute:: tmax
      :type:  float


   .. py:attribute:: dt
      :type:  float


   .. py:attribute:: x_grid
      :type:  numpy.ndarray


   .. py:attribute:: t_grid
      :type:  numpy.ndarray


   .. py:attribute:: maxk
      :type:  int


   .. py:attribute:: convergence_threshold
      :type:  float


   .. py:method:: initial_condition(param: numpy.ndarray) -> numpy.ndarray

      Evaluates the initial condition along the spatial grid. For this class, we use the
      following initial condition:
          u(x, 0) = a*exp(-x^2 / (2*w^2))
      where a and w are the corresponding parameter values.


      -------------------------------------------------------------------------------------------
      :Parameters: * **param** (*A 1d numpy.ndarray object with two elements corresponding to the values of the w*)
                   * **and a parameters. self.a_idx and self.w_idx tell us which index corresponds to which**
                   * **variable.**

      -------------------------------------------------------------------------------------------
      :returns: * *A 1d numpy.ndarray object of length self.grid_size[0] (the number of grid points along the*
                * *spatial axis).*



   .. py:method:: solve(param: numpy.ndarray) -> torch.Tensor

      Solves the 1d burgers equation when the IC uses the parameters in the param array.


      -------------------------------------------------------------------------------------------
      :Parameters: * **param** (*A 1d numpy.ndarray object with two elements corresponding to the values of the w*)
                   * **and a parameters. self.a_idx and self.w_idx tell us which index corresponds to which**
                   * **variable.**

      -------------------------------------------------------------------------------------------
      :returns: * *A 3d torch.Tensor object of shape (1, nt, nx), where nt is the number of points along the*
                * *temporal grid and nx is the number along the spatial grid.*



   .. py:method:: export() -> dict

      Returns a dictionary housing self's internal state. You can use this dictionary to
      effectively serialize self.



   .. py:method:: residual(Xhist: numpy.ndarray) -> tuple[numpy.ndarray, float]

      This function computes the PDE residual (difference between the left and right hand side
      of Burgers' equation when we substitute in the solution in Xhist).


      -------------------------------------------------------------------------------------------
      :Parameters: * **Xhist** (*A 2d numpy.ndarray object of shape (nt, nx), where nt is the number of points along*)
                   * **the temporal axis and nx is the number of points along the spatial axis. The i,j element of**
                   * **this array should have the j'th component of the solution at the i'th time step.**

      -------------------------------------------------------------------------------------------
      :returns: * *A two element tuple. The first is a numpy.ndarray object of shape (nt - 2, nx - 2) whose*
                * *i, j element holds the residual at the i + 1'th temporal grid point and the j + 1'th*
                * *spatial grid point.*



.. py:function:: residual_burgers(un, uw, c, idxn1)

   Compute 1D Burgers equation residual for generating the data
   from https://github.com/LLNL/gLaSDI and https://github.com/LLNL/LaSDI



.. py:function:: jacobian(u, c, idxn1, nx)

   Compute 1D Burgers equation jacobian for generating the data
   from https://github.com/LLNL/gLaSDI and https://github.com/LLNL/LaSDI



.. py:function:: solver(u0, maxk, convergence_threshold, nt, nx, Dt, Dx)

   Solves 1D Burgers equation for generating the data
   from https://github.com/LLNL/gLaSDI and https://github.com/LLNL/LaSDI



.. py:function:: main()

