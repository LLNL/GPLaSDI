lasdi.physics
=============

.. py:module:: lasdi.physics


Submodules
----------

.. toctree::
   :maxdepth: 1

   /autoapi/lasdi/physics/burgers1d/index


Classes
-------

.. autoapisummary::

   lasdi.physics.Physics
   lasdi.physics.OfflineFOM


Package Contents
----------------

.. py:class:: Physics(cfg: dict, param_name: list[str] = None)

   .. py:attribute:: dim
      :type:  int


   .. py:attribute:: qdim
      :type:  int


   .. py:attribute:: grid_size
      :type:  list[int]
      :value: []



   .. py:attribute:: qgrid_size
      :type:  list[int]
      :value: []


      numpy nd-array, assuming the shape of:
      - 1d: (space_dim[0],)
      - 2d: (2, space_dim[0], space_dim[1])
      - 3d: (3, space_dim[0], space_dim[1], space_dim[2])
      - higher dimension...


   .. py:attribute:: x_grid
      :type:  numpy.ndarray


   .. py:attribute:: nt
      :type:  int


   .. py:attribute:: dt
      :type:  float


   .. py:attribute:: t_grid
      :type:  numpy.ndarray


   .. py:attribute:: offline
      :type:  bool
      :value: False



   .. py:attribute:: param_name
      :type:  list[str]
      :value: None



   .. py:method:: initial_condition(param: numpy.ndarray) -> numpy.ndarray

      The user should write an instance of this method for their specific Physics sub-class.
      It should evaluate and return the initial condition along the spatial grid.


      -------------------------------------------------------------------------------------------
      :Parameters: * **param** (*A 1d numpy.ndarray object holding the value of self's parameters (necessary to*)
                   * **specify the IC).**

      -------------------------------------------------------------------------------------------
      :returns: * *A d-dimensional numpy.ndarray object of shape self.grid_size, where*
                * *d = len(self.grid_size). This should hold the IC evaluated on self's spatial grid*
                * *(self.x_grid)*



   .. py:method:: solve(param: numpy.ndarray) -> torch.Tensor

      The user should write an instance of this method for their specific Physics sub-class.
      This function should solve the underlying equation when the IC uses the parameters in
      param.


      -------------------------------------------------------------------------------------------
      :Parameters: * **param** (*A 1d numpy.ndarray object with two elements corresponding to the values of the*)
                   * **initial condition parameters.**

      -------------------------------------------------------------------------------------------
      :returns: * *A (ns + 2)-dimensional torch.Tensor object of shape (1, nt, nx[0], .. , nx[ns - 1]),*
                * *where nt is the number of points along the temporal grid and nx = self.grid_size specifies*
                * *the number of grid points along the axes in the spatial grid.*



   .. py:method:: export() -> dict

      This function should return a dictionary that houses self's state. I



   .. py:method:: generate_solutions(params: numpy.ndarray) -> torch.Tensor

      Given 2d-array of params, generate solutions of size params.shape[0]. params.shape[1] must
      match the required size of parameters for the specific physics.


      -------------------------------------------------------------------------------------------
      :Parameters: * **param** (*a 2d numpy.ndarray object of shape (np, n), where np is the number of combinations*)
                   * **of parameters we want to test and n denotes the number of parameters in self's initial**
                   * **condition function.**

      -------------------------------------------------------------------------------------------
      :returns: * *A torch.Tensor object of shape (np, nt, nx[0], .. , nx[ns - 1]), where nt is the number of*
                * *points along the temporal grid and nx = self.grid_size specifies the number of grid points*
                * *along the axes in the spatial grid.*



   .. py:method:: residual(Xhist: numpy.ndarray) -> tuple[numpy.ndarray, float]

      The user should write an instance of this method for their specific Physics sub-class.
      This function should compute the PDE residual (difference between the left and right hand
      side of of the underlying physics equation when we substitute in the solution in Xhist).


      -------------------------------------------------------------------------------------------
      :Parameters: * **Xhist** (*A (ns + 1)-dimensional numpy.ndarray object of shape self.grid_size  = (nt, nx[0],*)
                   * **... , nx[ns - 1]), where nt is the number of points along the temporal grid and nx =**
                   * **self.grid_size specifies the number of grid points along the axes in the spatial grid.**
                   * **The i,j(0), ... , j(ns - 1) element of this array should hold the value of the solution at**
                   * **the i'th time step and the spatial grid point with index (j(0), ... , j(ns - 1)).**

      -------------------------------------------------------------------------------------------
      :returns: * *A two element tuple. The first is a numpy.ndarray object holding the residual on the*
                * *spatial and temporal grid. The second should be a float holding the norm of the residual.*



.. py:class:: OfflineFOM(cfg, param_name=None)

   Bases: :py:obj:`Physics`


   .. py:attribute:: offline
      :value: True



   .. py:attribute:: dim


   .. py:attribute:: qdim


   .. py:attribute:: grid_size


   .. py:attribute:: qgrid_size

      numpy nd-array, assuming the shape of:
      - 1d: (space_dim[0],)
      - 2d: (2, space_dim[0], space_dim[1])
      - 3d: (3, space_dim[0], space_dim[1], space_dim[2])
      - higher dimension...


   .. py:attribute:: x_grid
      :value: None



   .. py:attribute:: nt


   .. py:attribute:: dt


   .. py:attribute:: t_grid


   .. py:method:: generate_solutions(params)

      Given 2d-array of params, generate solutions of size params.shape[0]. params.shape[1] must
      match the required size of parameters for the specific physics.


      -------------------------------------------------------------------------------------------
      :Parameters: * **param** (*a 2d numpy.ndarray object of shape (np, n), where np is the number of combinations*)
                   * **of parameters we want to test and n denotes the number of parameters in self's initial**
                   * **condition function.**

      -------------------------------------------------------------------------------------------
      :returns: * *A torch.Tensor object of shape (np, nt, nx[0], .. , nx[ns - 1]), where nt is the number of*
                * *points along the temporal grid and nx = self.grid_size specifies the number of grid points*
                * *along the axes in the spatial grid.*



   .. py:method:: export()

      This function should return a dictionary that houses self's state. I



